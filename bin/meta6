#! /usr/bin/env perl6

use v6;
use META6;
use HTTP::Client;
use Git::Config;
use JSON::Tiny;

my @path = «%*ENV<HOME>/.meta6»».IO;
my $cfg-dir = %*ENV<HOME>.IO.child('.meta6');
my $github-user = git-config<credential><username>;
my $github-realname = git-config<user><name>;
my $github-email = git-config<user><email>;

if $cfg-dir.e & !$cfg-dir.d {
    note "WARN: ⟨$cfg-dir⟩ is not a directory.";
}

sub first-hit($basename) {
    @path».child($basename).grep(*.e & *.r).first
}

sub try-to-fetch-url($_) {
    my $response = HTTP::Client.new.head(.Str, :follow);
    dd $response;
}

multi sub MAIN(Bool :$create-cfg-dir, Bool :$check, Str :$meta6-file-name = 'META6.json',
         Bool :$create, Bool :$force,
         Str :$name, Str :$description = '',
         Str :$version = (v0.0.1).Str, Str :$perl = (v6.c).Str,
         Str :$author =  "$github-realname <$github-email>",
         Str :$auth = "github:$github-user",
         Str :$base-dir = '.',
         Bool :$verbose
) {
    my IO::Path $meta6-file = ($base-dir ~ '/' ~ $meta6-file-name).IO;

    if $create-cfg-dir {
        die "⟨$cfg-dir⟩ already exists" if $cfg-dir.e;
        mkdir $cfg-dir and say "Created ⟨$cfg-dir⟩."
    }

    if $create {
        die "File ⟨$meta6-file⟩ already exists, the --force needs to be with you." if $meta6-file.e && !$force;
        die "To create a META6.json --name=<project-name-here> is required." unless $name;

        my $meta6 = META6.new(:$name, :$description, version => Version.new($version), perl-version => Version.new($perl), authors => [$author], :$auth,
                              source-url => "https://github.com/$github-user/$name",
                              depends => [ "Test::META" ],
                              provides => {}, license => 'Artistic 2.0', production => False);
        $meta6-file.spurt($meta6.to-json);
    }

    if $check {
        my $meta6 = META6.new(file => $meta6-file) or die "Failed to process ⟨$meta6-file⟩.";
        
        with $meta6<source-url> {
            if $meta6<source-url> ~~ /^ 'git://' / {
                note „WARN: Schema git:// used in source-url. Use https:// to avoid logins and issues thanks to dependence on git.“;
            }
            if !try-to-fetch-url($meta6<source-url>) {
                note „WARN: Failed to reach $meta6<source-url>.“;
            }
        }
    }
}

multi sub MAIN(Str :$new-module, Bool :$force, Bool :$skip-git, Bool :$skip-github, :$verbose) {
    my $name = $new-module;
    die "To create a module --new-module=<Module::Name::Here> is required." unless $name;
    my $base-dir = 'perl6-' ~ $name.subst(:g, '::', '-').fc;
    die "Directory ⟨$base-dir⟩ already exists, the --force needs to be with you." if $base-dir.IO.e && !$force;
    say "Creating new module $name under ⟨$base-dir⟩.";
    $base-dir.IO.mkdir or die "Cannot create ⟨$base-dir⟩: $!";
    for <lib t bin example> {
        my $dir = $base-dir ~ '/' ~ .Str;
        $dir.IO.mkdir or die "Cannot create ⟨$dir⟩: $!";
    }

    create-readme($base-dir, $name);
    create-meta-t($base-dir);
    create-travis-yml($base-dir);

    MAIN(:create, :$name, :$base-dir, :$force);
    git-create($base-dir) unless $skip-git;
    github-create($base-dir) unless $skip-git && $skip-github;
    git-push($base-dir, :$verbose) unless $skip-git && $skip-github;
}

sub git-create($base-dir) {
    my Promise $p;

    my $git = Proc::Async.new('git', 'init', $base-dir);
    my $timeout = Promise.at(now + 60);

    await Promise.anyof($p = $git.start, $timeout);
    fail "⟨git init⟩ timed out." if $p.status == Broken;
    
    $git = Proc::Async.new('git', '-C', $base-dir, 'add', 'META6.json', 'README.md', '.travis.yml', 't/meta.t');
    $timeout = Promise.at(now + 60);
    
    await Promise.anyof($p = $git.start, $timeout);
    fail "⟨git add⟩ timed out." if $p.status == Broken;
    
    $git = Proc::Async.new('git', '-C', $base-dir, 'commit', 'META6.json', 'README.md', '.travis.yml', 't/meta.t', '-m', 'initial commit, add META6.json, README.md, .travis.yml, meta.t');
    $timeout = Promise.at(now + 60);
    
    await Promise.anyof($p = $git.start, $timeout);
    fail "⟨git commit⟩ timed out." if $p.status == Broken;
}

sub github-create($base-dir) {
    # say 'curl', '-u', $github-user, 'https://api.github.com/user/repos', '-d', '{"name":"' ~ $base-dir ~ '"}';
    my $curl = Proc::Async.new('curl', '--silent', '-u', $github-user, 'https://api.github.com/user/repos', '-d', '{"name":"' ~ $base-dir ~ '"}');
    my Promise $p;
    my $github-response;
    $curl.stdout.tap: { $github-response ~= .Str };
    my $timeout = Promise.at(now + 60);

    say "Creating github repo.";
    await Promise.anyof($p = $curl.start, $timeout);
    fail "⟨curl⟩ timed out." if $p.status == Broken;
    
    given from-json($github-response) {
        when .<errors>:exists {
            fail .<message>.subst(:g, '.', ''), ": ", .<errors>.[0].<message>.subst('name', $base-dir), '.';
        }
        when .<full_name>:exists {
            say 'GitHub project created at https://github.com/' ~ .<full_name> ~ '.';
        }
    }
}

sub git-push($base-dir, :$verbose) {
    my Promise $p;

    my $git = Proc::Async.new('git', '-C', $base-dir, 'remote', 'add', 'origin', "https://github.com/$github-user/$base-dir");
    $git.stdout.tap: { Nil } unless $verbose;
    my $timeout = Promise.at(now + 60);
    
    await Promise.anyof($p = $git.start, $timeout);
    fail "⟨git remote⟩ timed out." if $p.status == Broken;
    
    say "Pushing repo to github.";
    $git = Proc::Async.new('git', '-C', $base-dir, 'push', 'origin', 'master');
    $git.stdout.tap: { Nil } unless $verbose;
    $timeout = Promise.at(now + 60);
    
    await Promise.anyof($p = $git.start, $timeout);
    fail "⟨git push⟩ timed out." if $p.status == Broken;
}

sub create-readme($base-dir, $name) {
    spurt("$base-dir/README.md", qq:to<EOH>);
    # $name
    
    [![Build Status](https://travis-ci.org/$github-user/$base-dir.svg?branch=master)](https://travis-ci.org/$github-user/$base-dir)

    ## SYNOPSIS
    
    ```
    use $name;
    ```
    
    ## LICENSE
    
    All files (unless noted otherwise) can be used, modified and redistributed
    under the terms of the Artistic License Version 2. Examples (in the
    documentation, in tests or distributed as separate files) can be considered
    public domain.
    
    ⓒ{ now.Date.year } $github-realname
    EOH
}

sub create-meta-t($base-dir) {
    spurt("$base-dir/t/meta.t", Q:to<EOH>);
    use v6;
    
    use lib 'lib';
    use Test;
    use Test::META;
    
    meta-ok;
    
    done-testing;
    EOH
}

sub create-travis-yml($base-dir) {
    spurt("$base-dir/.travis.yml", Q:to<EOH>);
    language: perl6
    sudo: false
    perl6:
        - latest
    install:
        - rakudobrew build-zef
        - zef install .
    EOH
}
